<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Smart Pricing Engine</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg:#0b0c0f; --card:#111318; --muted:#9aa4af; --text:#e8edf2; --accent:#6aa5ff;
      --good:#1db954; --bad:#ff6b6b; --chip:#1b1f27; --border:#1d2230; --tableStripe:#0f1218;
    }
    [data-theme="light"]{
      --bg:#f5f7fb; --card:#ffffff; --muted:#657487; --text:#0d1220; --accent:#1d4ed8;
      --good:#16a34a; --bad:#dc2626; --chip:#eef2ff; --border:#e5e7eb; --tableStripe:#f8fafc;
    }
    *{box-sizing:border-box}
    body{ margin:0; background:var(--bg); color:var(--text);
      font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      line-height:1.5; padding:24px;}
    .container{max-width:1100px;margin:0 auto}
    .header{ display:flex; align-items:center; justify-content:space-between; gap:16px; flex-wrap:wrap; margin-bottom:16px;}
    h1{font-size:28px; margin:0; letter-spacing:.2px}
    .controls{display:flex; gap:8px; flex-wrap:wrap}
    button{
      background:var(--accent); color:white; border:none; border-radius:12px; padding:10px 14px;
      font-weight:700; cursor:pointer; box-shadow:0 6px 20px rgba(0,0,0,.12);
      transition:transform .05s ease, filter .2s ease;
    }
    button.secondary{background:transparent; color:var(--text); border:1px solid var(--border); font-weight:600}
    button.icon{width:40px; height:40px; border-radius:12px; display:grid; place-items:center}
    button:hover{filter:brightness(1.05)} button:active{transform:translateY(1px)}
    .card{ background:var(--card); border:1px solid var(--border); border-radius:16px; padding:16px;
      box-shadow:0 10px 30px rgba(0,0,0,.18); margin-bottom:16px;}
    .kpis{display:grid; grid-template-columns:repeat(3,1fr); gap:12px}
    .kpi h3{margin:0; font-size:12px; color:var(--muted); text-transform:uppercase; letter-spacing:.08em}
    .kpi .value{font-size:22px; font-weight:700; margin-top:6px}
    .kpi .sub{font-size:12px; color:var(--muted)}
    .filters{display:flex; gap:10px; flex-wrap:wrap; margin-top:8px; align-items:center}
    input[type="text"], select{
      background:transparent; color:var(--text); border:1px solid var(--border); border-radius:10px;
      padding:10px 12px; min-width:220px; outline:none;
    }
    .chips{display:flex; gap:8px; margin-left:auto}
    .chip{ display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px;
      background:var(--chip); font-size:12px; border:1px solid var(--border)}
    @media (max-width: 720px){
      .kpis{grid-template-columns:1fr}
      .chart-wrap{flex-direction:column}
      #chart{width:100%; height:260px}
      table{display:block; overflow-x:auto; white-space:nowrap}
    }
    table{width:100%; border-collapse:separate; border-spacing:0; border:1px solid var(--border); border-radius:12px; overflow:hidden}
    thead th{
      background:var(--card); position:sticky; top:0; z-index:1; font-size:12px; color:var(--muted);
      text-transform:uppercase; letter-spacing:.06em; padding:10px 12px; border-bottom:1px solid var(--border); cursor:pointer;
    }
    tbody td{padding:12px; border-bottom:1px solid var(--border)}
    tbody tr:nth-child(odd){background:var(--tableStripe)}
    .money{white-space:nowrap}
    .delta{font-weight:700}
    .delta.good{color:var(--good)} .delta.bad{color:var(--bad)}
    .legend{display:flex; gap:10px; align-items:center; color:var(--muted); font-size:12px}
    .chart-wrap{display:flex; gap:14px; align-items:flex-start; flex-wrap:wrap}
    #chart{background:var(--card); border:1px solid var(--border); border-radius:12px}
    #slider{width:320px}
    .muted{color:var(--muted)}
    .pill{border:1px solid var(--border); border-radius:999px; padding:6px 10px}
    .hidden{display:none}
  </style>
</head>
<body data-theme="dark">
  <div class="container">
    <div class="header">
      <h1>Smart Pricing Engine</h1>
      <div class="controls">
        <button id="runBtn" onclick="runPricing()">Run Pricing</button>
        <button class="secondary" onclick="downloadCSV()">Download CSV</button>
        <button class="secondary icon" onclick="toggleTheme()" title="Toggle light/dark">ðŸŒ™</button>
      </div>
    </div>

    <!-- KPIs -->
    <div class="card kpis">
      <div class="kpi">
        <h3>Expected Profit Uplift</h3>
        <div class="value" id="kpiUplift">$0.00</div>
        <div class="sub muted">vs current prices</div>
      </div>
      <div class="kpi">
        <h3>Price Changes</h3>
        <div class="value"><span id="kpiUp">0 â†‘</span> Â· <span id="kpiDown">0 â†“</span></div>
        <div class="sub muted">count of increases / decreases</div>
      </div>
      <div class="kpi">
        <h3>Average Margin</h3>
        <div class="value" id="kpiMargin">â€”</div>
        <div class="sub muted">weighted by expected units (est.)</div>
      </div>
    </div>

    <!-- Filters -->
    <div class="card">
      <div class="filters">
        <input id="search" type="text" placeholder="Search productsâ€¦" oninput="renderTable()" />
        <select id="category" onchange="renderTable()">
          <option value="">All categories</option>
        </select>
        <div class="chips">
          <span class="chip">Low inventory</span>
          <span class="chip">OK</span>
          <span class="chip">High inventory</span>
        </div>
      </div>
    </div>

    <!-- Table -->
    <div class="card">
      <table id="table">
        <thead>
          <tr>
            <th onclick="sortBy('name')">Product</th>
            <th onclick="sortBy('product_id')">ID</th>
            <th onclick="sortBy('current_price')">Current Price</th>
            <th onclick="sortBy('recommended_price')">Recommended</th>
            <th onclick="sortBy('expected_profit_delta')">Delta</th>
            <th>Inventory</th>
            <th>Notes</th>
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
      </table>
    </div>

    <!-- Chart -->
    <div class="card">
      <div class="chart-wrap">
        <div>
          <div class="muted" style="margin-bottom:6px;">Profit vs Price</div>
          <svg id="chart" width="700" height="340"></svg>
          <div style="display:flex; align-items:center; gap:12px; margin-top:10px;">
            <input id="slider" type="range" min="0" max="100" value="0" oninput="moveMarker(this.value)" />
            <span id="sliderLabel" class="pill">Select product</span>
          </div>
        </div>
        <div style="min-width:260px">
          <div class="muted" style="margin-bottom:6px;">Select product</div>
          <select id="productSelect" style="min-width:260px; padding:10px" onchange="showCurve()"></select>
          <ul class="muted" style="margin-top:10px">
            <li>Green line = recommended price</li>
            <li>Gray line = current price</li>
            <li>Red line = slider position</li>
          </ul>
        </div>
      </div>
    </div>
  </div>

  <script>
  
let fullData = null, filtered = [], currentSort = { key:'expected_profit_delta', dir:'desc' }, currentCurve=null;

/* ---------- THEME ---------- */
function toggleTheme(){
  const el=document.body; el.setAttribute('data-theme', el.getAttribute('data-theme')==='light'?'dark':'light');
}

/* ---------- HELPERS ---------- */
const money=v=> (isFinite(v)?`$${Number(v).toFixed(2)}`:'â€”');
const pct  =v=> (isFinite(v)?`${(Number(v)*100).toFixed(1)}%`:'â€”');
const toNum=v=> (v===null||v===''||v===undefined)?NaN:Number(v);
const clamp=(v,lo,hi)=> Math.max(lo, Math.min(hi, v));
const escapeHtml=s=>String(s??'').replace(/[&<>"']/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
function pick(row, keys){ for(const k of keys){ if(k in row && row[k]!=='' && row[k]!==undefined) return row[k]; } }

/* ---------- CSV PARSER ---------- */
function parseCSV(text){
  const lines=text.replace(/\r/g,'').split('\n').filter(l=>l.trim().length);
  if(!lines.length) return {header:[], rows:[]};
  const header=splitCSVLine(lines[0]).map(h=>h.trim());
  const rows=[];
  for(let i=1;i<lines.length;i++){
    const cols=splitCSVLine(lines[i]);
    const obj={}; header.forEach((h,idx)=> obj[h]=(cols[idx]??'').trim());
    rows.push(obj);
  }
  return {header,rows};
}
function splitCSVLine(line){
  const out=[]; let cur='',inQ=false;
  for(let i=0;i<line.length;i++){
    const ch=line[i], nx=line[i+1];
    if(ch === '"' && inQ && nx === '"'){ cur+='"'; i++; continue; }
    if(ch === '"'){ inQ=!inQ; continue; }
    if(ch === ',' && !inQ){ out.push(cur); cur=''; continue; }
    cur+=ch;
  }
  out.push(cur); return out;
}

/* ---------- FILE LOADERS ---------- */
async function tryFetchText(paths){
  for(const p of paths){
    try{ const res=await fetch(p,{cache:'no-store'}); if(res.ok) return await res.text(); }catch(_){}
  }
  return null;
}
async function loadCSV(name){  // tries /data/name then /name
  return await tryFetchText([`data/${name}`, name]);
}

/* ---------- ENTRYPOINT ---------- */
async function runPricing(){
  const btn=document.getElementById('runBtn'); if(btn){ btn.disabled=true; btn.textContent='Runningâ€¦'; }
  try{
    // Preferred: compute from separate CSVs
    const [pTxt,iTxt,sTxt,cTxt] = await Promise.all([
      loadCSV('products.csv'),
      loadCSV('inventory.csv'),
      loadCSV('sales_history.csv'),
      loadCSV('competitors.csv'),
    ]);

    if (pTxt){ await computeFromSources(pTxt,iTxt,sTxt,cTxt); return; }

    // Fallback: show precomputed recommendations
    const recTxt = await loadCSV('price_recommendations.csv');
    if(recTxt){ processRecommendations(recTxt); return; }

    alert('No data found. Add products.csv (and optionally inventory.csv, sales_history.csv, competitors.csv) under /data/.');

  } finally {
    if(btn){ btn.disabled=false; btn.textContent='Run Pricing'; }
  }
}

/* ---------- PIPELINES ---------- */
async function computeFromSources(productsTxt, invTxt, salesTxt, compTxt){
  // 1) Parse
  const products = parseCSV(productsTxt).rows;
  const invRows  = invTxt   ? parseCSV(invTxt).rows   : [];
  const saleRows = salesTxt ? parseCSV(salesTxt).rows : [];
  const compRows = compTxt  ? parseCSV(compTxt).rows  : [];

  // 2) Fold to maps (flexible headers)
  const invMap  = new Map();
  invRows.forEach(r=>{
    const id  = (pick(r,['product_id','id','pid','SKU','sku'])??'').toString();
    const inv = toNum(pick(r,['inventory_on_hand','on_hand','inventory','stock','qty']));
    const rop = toNum(pick(r,['reorder_point','reorder','rop','min_stock']));
    if(id) invMap.set(id,{inv,rop});
  });

  // sales history: we expect rows with (product_id, date, units OR revenue)
  const salesMap = new Map(); // id -> {recent, prev}
  if(saleRows.length){
    // Partition last 28d vs previous 28d (by date string; accepts yyyy-mm-dd or mm/dd/yyyy)
    const now = new Date();
    function parseDate(s){ const d=new Date(s); return isNaN(d)?null:d; }
    saleRows.forEach(r=>{
      const id = (pick(r,['product_id','id','pid','SKU','sku'])??'').toString(); if(!id) return;
      const dateStr = pick(r,['date','day','dt','order_date','txn_date']) ?? '';
      const dt = parseDate(dateStr); if(!dt) return;
      const units = toNum(pick(r,['units','qty','quantity','sales_units']));
      const revenue = toNum(pick(r,['revenue','sales','amount']));
      const val = isFinite(units) ? units : (isFinite(revenue) ? revenue : NaN);
      if(!isFinite(val)) return;
      const days = (now - dt)/86400000;
      const bucket = days <= 28 ? 'recent' : (days<=56 ? 'prev' : null);
      if(!bucket) return;
      const rec = salesMap.get(id) || {recent:0, prev:0};
      rec[bucket]+= val; salesMap.set(id, rec);
    });
  }

  const compMap = new Map();
  compRows.forEach(r=>{
    const id  = (pick(r,['product_id','id','pid','SKU','sku'])??'').toString();
    const cp1 = toNum(pick(r,['competitor_price','competitor','min_competitor','comp_price','price']));
    const cp2 = toNum(pick(r,['competitor_price_2','price2']));
    const comp = isFinite(cp1) && isFinite(cp2) ? Math.min(cp1,cp2) : (isFinite(cp1)?cp1:cp2);
    if(id && isFinite(comp)) compMap.set(id, comp);
  });

  // 3) Build recommendations row-by-row
  const recs = products.map(r=>{
    const id    = (pick(r,['product_id','id','pid','SKU','sku'])??'').toString();
    const name  = pick(r,['name','product','title']) ?? '(No name)';
    const cat   = pick(r,['category','cat','dept']) ?? '';
    let cur     = toNum(pick(r,['current_price','current','price','current_pr','curr_price','list_price']));
    let cost    = toNum(pick(r,['unit_cost','cost','cogs']));
    // Fallbacks to avoid 0s
    if(!isFinite(cur) && isFinite(cost)) cur = cost * 1.20;
    if(!isFinite(cost) && isFinite(cur)) cost = cur * 0.70;
    if(!isFinite(cur) && !isFinite(cost)) { cur = 10; cost = 7; }

    const invInfo = invMap.get(id) || {};
    let inv = invInfo.inv; let rop = invInfo.rop;
    if(!isFinite(inv)) inv = NaN;
    if(!isFinite(rop)) rop = isFinite(inv) ? Math.max(1, inv*0.4) : 10;

    // Demand from sales trend (recent 28d vs previous 28d)
    let demandIdx = 0.5;
    const s = salesMap.get(id);
    if(s){
      const base = (s.prev>0 ? s.prev : (s.recent>0 ? s.recent : 1));
      const growth = (s.recent - s.prev)/base;              // can be negative/positive
      demandIdx = clamp(0.5 + 0.35*growth, 0.05, 0.95);     // translate growth â†’ [0.05..0.95]
    }

    // Competitor gap (if any)
    const compPrice = compMap.get(id);
    let compAdj = 0;
    if(isFinite(compPrice) && isFinite(cur) && cur>0){
      const gap = (cur - compPrice)/cur; // positive if we are more expensive
      // Nudge downwards if weâ€™re >5% above competitor; cap to -10%
      compAdj = clamp(-0.5 * Math.max(0, gap - 0.05), -0.10, 0.00);
    }

    // Inventory pressure
    const scarcity = (isFinite(inv) && isFinite(rop) && rop>0) ? clamp((rop - inv)/rop * 0.20, -0.15, 0.25) : 0;

    // Base margin & demand influence
    const baseMargin = 0.15;
    const demandAdj  = (demandIdx - 0.5) * 0.30; // [-15%, +15%]

    // 1) Target from cost & signals (additive %s)
    const target = cost * (1 + baseMargin + demandAdj + scarcity + compAdj);

    // 2) Blend toward target (avoid big jumps)
    let recPrice = (isFinite(cur) ? (0.6*cur + 0.4*target) : target);

    // 3) Guardrails: at most -5% / +10% vs current; never below cost+5%
    if(isFinite(cur)){
      const downLimit = Math.max(cost*1.05, cur*0.95);
      const upLimit   = cur * 1.10;
      recPrice = Math.min(upLimit, Math.max(downLimit, recPrice));
    }
    if(!isFinite(recPrice) || recPrice<=0) recPrice = Math.max(0.01, isFinite(cur)?cur:(cost*1.1));

    // 4) Profit model (elasticity softly larger if competitor undercuts us)
    let elasticity = -0.8;
    if(isFinite(compPrice) && compPrice < cur) elasticity = -1.0;

    const baseUnits   = 100 * (0.5 + demandIdx); // 55â€“145
    const priceChange = (isFinite(cur) && cur>0) ? (recPrice - cur)/cur : 0;
    const units       = baseUnits * (1 + elasticity * priceChange);

    const profitNow = (isFinite(cur)&&isFinite(cost)) ? (cur - cost) * baseUnits : 0;
    let   profitRec = (recPrice - cost) * Math.max(0, units);
    let   delta     = profitRec - profitNow;

    const profitThreshold = profitNow * -0.05;
    if (!isFinite(delta) || delta < profitThreshold) {
     recPrice = isFinite(cur) ? cur : recPrice;
     profitRec = profitNow;
     delta = 0;
    }

    return {
      product_id:id, name, category:cat,
      current_price:cur, recommended_price:recPrice, unit_cost:cost,
      inventory_on_hand:inv, reorder_point:rop,
      expected_profit_delta:delta,
      notes:isFinite(compPrice) ? `Comp $${compPrice.toFixed(2)}` : ''
    };
  });

  fullData = { recommendations: recs };
  afterDataLoad();
}

function processRecommendations(csvText){
  const {rows} = parseCSV(csvText);
  rows.forEach(r=>{
    r.product_id = (pick(r,['product_id','id','pid','SKU','sku'])??'').toString();
    r.name = pick(r,['name','product','title']) ?? '(No name)';
    r.category = pick(r,['category','cat','dept']) ?? '';
    r.current_price = toNum(pick(r,['current_price','current','price','current_pr','curr_price','list_price']));
    r.recommended_price = toNum(pick(r,['recommended_price','rec_price','target_price','suggested']));
    r.unit_cost = toNum(pick(r,['unit_cost','cost','cogs']));
    r.inventory_on_hand = toNum(pick(r,['inventory_on_hand','inventory','stock','on_hand','qty']));
    r.reorder_point = toNum(pick(r,['reorder_point','reorder','rop','min_stock']));
    r.expected_profit_delta = toNum(pick(r,['expected_profit_delta','profit_delta','uplift']));
    r.notes = pick(r,['notes','note','desc','description']) ?? '';
  });
  fullData = { recommendations: rows };
  afterDataLoad();
}

/* ---------- POST-LOAD UI ---------- */
function afterDataLoad(){
  populateCategoryFilter();
  computeKPIs();
  renderTable();
  populateProductSelect();
  drawEmptyChart();
  const lbl=document.getElementById('sliderLabel'); if(lbl) lbl.textContent='Select product';
}

/* ---------- KPIs ---------- */
function computeKPIs(){
  if(!fullData) return;
  const rows=fullData.recommendations;
  const uplift = rows.reduce((acc,r)=> acc+(Number(r.expected_profit_delta)||0), 0);
  const up = rows.filter(r=> r.recommended_price > r.current_price).length;
  const down = rows.filter(r=> r.recommended_price < r.current_price).length;

  const margins = rows.map(r=>{
    const rp=Number(r.recommended_price), uc=Number(r.unit_cost);
    if(!isFinite(rp)||!isFinite(uc)||rp<=0) return NaN;
    return (rp-uc)/rp;
  }).filter(x=>isFinite(x));
  const avgMargin = margins.length ? (margins.reduce((a,b)=>a+b,0)/margins.length) : NaN;

  document.getElementById('kpiUplift').textContent = money(uplift);
  document.getElementById('kpiUp').textContent = `${up} â†‘`;
  document.getElementById('kpiDown').textContent = `${down} â†“`;
  document.getElementById('kpiMargin').textContent = pct(avgMargin);
}

/* ---------- FILTERS + TABLE ---------- */
function populateCategoryFilter(){
  const sel=document.getElementById('category');
  const cats=Array.from(new Set((fullData?.recommendations||[]).map(r=>r.category).filter(Boolean))).sort();
  sel.innerHTML='<option value="">All categories</option>'+cats.map(c=>`<option>${escapeHtml(c)}</option>`).join('');
}
function renderTable(){
  if(!fullData) return;
  const q=document.getElementById('search').value.toLowerCase();
  const cat=document.getElementById('category').value;
  filtered=fullData.recommendations.filter(r=>{
    const matchesQ = !q || (r.name||'').toLowerCase().includes(q) || (r.product_id||'').toLowerCase().includes(q);
    const matchesC = !cat || r.category===cat;
    return matchesQ && matchesC;
  });
  sortData();
  const tbody=document.getElementById('tbody');
  tbody.innerHTML=filtered.map(r=>{
    const deltaClass = Number(r.expected_profit_delta)>=0 ? 'delta good' : 'delta bad';
    const inv=Number(r.inventory_on_hand), rp=Number(r.reorder_point);
    let invBadge='<span class="chip">OK</span>';
    if(isFinite(inv)&&isFinite(rp)){
      if(inv<=rp) invBadge='<span class="chip" style="border-color:var(--bad);color:var(--bad)">Low</span>';
      else if(inv>2*rp) invBadge='<span class="chip" style="border-color:var(--good);color:var(--good)">High</span>';
    }
    return `
      <tr>
        <td>${escapeHtml(r.name||'(No name)')}</td>
        <td>${escapeHtml(r.product_id)}</td>
        <td class="money">${money(r.current_price)}</td>
        <td class="money"><b>${money(r.recommended_price)}</b></td>
        <td class="${deltaClass}">${isFinite(r.expected_profit_delta)? Number(r.expected_profit_delta).toFixed(2) : 'â€”'}</td>
        <td>${invBadge}</td>
        <td class="muted">${escapeHtml(r.notes||'')}</td>
      </tr>
    `;
  }).join('');
}
function sortBy(key){
  if(currentSort.key===key){ currentSort.dir = currentSort.dir==='asc'?'desc':'asc'; }
  else { currentSort={key,dir:'asc'}; }
  renderTable();
}
function sortData(){
  const dir=currentSort.dir==='asc'?1:-1;
  filtered.sort((a,b)=>{
    const va=a[currentSort.key], vb=b[currentSort.key];
    if(typeof va==='string' && typeof vb==='string') return va.localeCompare(vb)*dir;
    return (((Number(va)||0) - (Number(vb)||0)) * dir);
  });
}

/* ---------- DOWNLOAD ---------- */
function downloadCSV(){
  if(!fullData || !fullData.recommendations){ alert('Run pricing first.'); return; }
  const rows=fullData.recommendations;
  const header=["product_id","name","category","current_price","recommended_price","unit_cost","inventory_on_hand","reorder_point","expected_profit_delta","notes"];
  const csv=[ header.join(","), ...rows.map(r=> header.map(h=> `"${(r[h]??'').toString().replace(/"/g,'""')}"`).join(",")) ].join("\n");
  const blob=new Blob([csv],{type:'text/csv'}); const url=URL.createObjectURL(blob);
  const a=document.createElement('a'); a.href=url; a.download='price_recommendations.csv'; a.click(); URL.revokeObjectURL(url);
}

/* ---------- CHART ---------- */
function populateProductSelect(){
  const sel=document.getElementById('productSelect'); if(!sel) return;
  sel.innerHTML=''; (filtered||[]).forEach(r=>{
    const opt=document.createElement('option');
    opt.value=r.product_id; opt.textContent=(r.name?`${r.name} â€” ${r.product_id}`:r.product_id); sel.appendChild(opt);
  });
  if(sel.options.length){ sel.value=sel.options[0].value; showCurve(); }
}
function showCurve(){
  const sel=document.getElementById('productSelect'); if(!sel) return;
  const pid=sel.value; const row=(filtered||[]).find(r=>r.product_id===pid);
  if(!row){ drawEmptyChart(); const lbl=document.getElementById('sliderLabel'); if(lbl) lbl.textContent='No curve data'; return; }

  const Pc=Number(row.current_price), Pr=Number(row.recommended_price), delta=Number(row.expected_profit_delta);
  const baseProfit=0, vertexProfit=baseProfit+(isFinite(delta)?delta:0);
  const k=(Pr!==Pc)? (vertexProfit-baseProfit)/((Pr-Pc)*(Pr-Pc)) : 0.01;

  const prices=[]; const span=Math.max(Pr,Pc)*0.6 + Math.max(Pr,Pc,10);
  const minP=Math.max(0.01, Math.min(Pr,Pc)-span*0.5); const maxP=Math.max(Pr,Pc)+span*0.5; const steps=60;
  for(let i=0;i<=steps;i++){ const p=minP+(i/steps)*(maxP-minP); const profit=vertexProfit - k*(p-Pr)*(p-Pr); prices.push({price:p,profit}); }

  currentCurve={product_id:row.product_id,name:row.name,current_price:Pc,recommended_price:Pr,points:prices};
  drawChart(currentCurve); setupSlider(currentCurve);
}
function drawEmptyChart(){ const svg=document.getElementById('chart'); while(svg && svg.firstChild) svg.removeChild(svg.firstChild); }
function drawChart(curve){
  const svg=document.getElementById('chart'); while(svg.firstChild) svg.removeChild(svg.firstChild);
  const W=Number(svg.getAttribute('width')), H=Number(svg.getAttribute('height'));
  const pad=38, ox=pad, oy=pad, iw=W-pad*2, ih=H-pad*2;

  const prices=curve.points.map(p=>p.price), profits=curve.points.map(p=>p.profit);
  const minP=Math.min(...prices), maxP=Math.max(...prices);
  const minY=Math.min(0,...profits), maxY=Math.max(...profits);

  const X=v=> ox + ((v-minP)/(maxP-minP || 1)) * iw;
  const Y=v=> oy + (1 - ((v-minY)/(maxY-minY || 1))) * ih;

  const mkLine=(x1,y1,x2,y2,st="#3a4154",w=1,ds=null)=>{
    const l=document.createElementNS("http://www.w3.org/2000/svg","line");
    l.setAttribute("x1",x1); l.setAttribute("y1",y1); l.setAttribute("x2",x2); l.setAttribute("y2",y2);
    l.setAttribute("stroke",st); l.setAttribute("stroke-width",w); if(ds) l.setAttribute("stroke-dasharray",ds);
    svg.appendChild(l);
  };
  mkLine(ox, oy+ih, ox+iw, oy+ih); mkLine(ox, oy, ox, oy+ih);

  let d=""; curve.points.forEach((pt,i)=>{ d += (i?" L ":"M ") + X(pt.price) + " " + Y(pt.profit); });
  const path=document.createElementNS("http://www.w3.org/2000/svg","path");
  path.setAttribute("d",d); path.setAttribute("fill","none");
  path.setAttribute("stroke", getComputedStyle(document.body).getPropertyValue('--accent').trim() || "#6aa5ff");
  path.setAttribute("stroke-width","2.5"); svg.appendChild(path);

  mkLine(X(curve.current_price), oy, X(curve.current_price), oy+ih, "#8b93a6", 1, "5,4");
  mkLine(X(curve.recommended_price), oy, X(curve.recommended_price), oy+ih, "#22c55e", 1.5, "5,4");

  const m=document.createElementNS("http://www.w3.org/2000/svg","line");
  m.setAttribute("id","sliderMarker"); m.setAttribute("y1",oy); m.setAttribute("y2",oy+ih);
  m.setAttribute("stroke","#ef4444"); m.setAttribute("stroke-width","2"); svg.appendChild(m);
  moveMarkerTo(curve.recommended_price, curve);
  const lbl=document.getElementById('sliderLabel'); if(lbl) lbl.textContent=`${curve.name||curve.product_id}`;
}
function setupSlider(curve){
  const slider=document.getElementById('slider'); if(!slider) return;
  const prices=curve.points.map(p=>p.price); const minP=Math.min(...prices), maxP=Math.max(...prices);
  slider.min=minP; slider.max=maxP; slider.step=((maxP-minP)/100).toFixed(2); slider.value=curve.recommended_price;
  updateSliderLabel(curve.recommended_price, curve);
}
function moveMarker(val){ if(!currentCurve) return; const price=parseFloat(val); moveMarkerTo(price,currentCurve); updateSliderLabel(price,currentCurve); }
function moveMarkerTo(price,curve){
  const svg=document.getElementById('chart'); const W=Number(svg.getAttribute('width')), H=Number(svg.getAttribute('height'));
  const pad=38, ox=pad, oy=pad, iw=W-pad*2, ih=H-pad*2; const prices=curve.points.map(p=>p.price);
  const minP=Math.min(...prices), maxP=Math.max(...prices); const X=v=> ox + ((v-minP)/(maxP-minP || 1))*iw;
  const marker=document.getElementById('sliderMarker'); marker.setAttribute('x1',X(price)); marker.setAttribute('x2',X(price));
}
function updateSliderLabel(price,curve){
  const lbl=document.getElementById('sliderLabel'); if(!lbl) return;
  let nearest=curve.points[0]; curve.points.forEach(p=>{ if(Math.abs(p.price-price)<Math.abs(nearest.price-price)) nearest=p; });
  lbl.textContent=`${curve.name||curve.product_id} â€” Price $${Number(price).toFixed(2)} â€¢ Profit â‰ˆ ${money(nearest.profit)}`;
}
</script>
</body>
</html>